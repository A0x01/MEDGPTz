import { useState, useRef } from 'react';
import { toast } from 'sonner';
import { Deck, Flashcard, ViewMode, ExportSettings, Folder } from './types';
import { initialDecks, sampleCards, initialFolders } from './data/mockData';
import { generateMockFlashcards } from './utils';
import { getDescendantIds } from './utils/folderUtils';
import { DeckListView } from './views/DeckListView';
import { CreateDeckDialog } from './components/CreateDeckDialog';
import { UploadView } from './views/UploadView';
import { GeneratingView } from './views/GeneratingView';
import { ReviewCardsView } from './views/ReviewCardsView';
import { ExportView } from './views/ExportView';

export function MedCards() {
  const [decks, setDecks] = useState<Deck[]>(initialDecks);
  const [cards, setCards] = useState<Flashcard[]>(sampleCards);
  const [folders, setFolders] = useState<Folder[]>(initialFolders);
  const [selectedFolderId, setSelectedFolderId] = useState<string | null>(null);
  const [selectedDeck, setSelectedDeck] = useState<Deck | null>(null);
  const [viewMode, setViewMode] = useState<ViewMode>('decks');
  const [searchQuery, setSearchQuery] = useState('');
  const [isCreatingDeck, setIsCreatingDeck] = useState(false);
  const [uploadedFile, setUploadedFile] = useState<File | null>(null);
  const [generationProgress, setGenerationProgress] = useState(0);
  const [generatedCards, setGeneratedCards] = useState<Flashcard[]>([]);
  const [selectedCards, setSelectedCards] = useState<Set<string>>(new Set());
  const [isDragging, setIsDragging] = useState(false);
  const [exportSettings, setExportSettings] = useState<ExportSettings>({
    includeScheduling: false,
    cardType: 'all',
  });

  // Handle file upload
  const handleFileSelect = (file: File) => {
    if (file.type === 'application/pdf' || file.name.endsWith('.pdf')) {
      setUploadedFile(file);
      toast.success(`File "${file.name}" uploaded`);
    } else {
      toast.error('Please upload a PDF file');
    }
  };

  // Drag and drop handlers
  const handleDragOver = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(true);
  };

  const handleDragLeave = () => {
    setIsDragging(false);
  };

  const handleDrop = (e: React.DragEvent) => {
    e.preventDefault();
    setIsDragging(false);
    const file = e.dataTransfer.files[0];
    if (file) {
      handleFileSelect(file);
    }
  };

  // Generate flashcards
  const handleGenerateFlashcards = () => {
    if (!uploadedFile || !selectedDeck) return;

    setViewMode('generating');
    setGenerationProgress(0);

    const interval = setInterval(() => {
      setGenerationProgress((prev) => {
        if (prev >= 100) {
          clearInterval(interval);
          const mockGenerated = generateMockFlashcards(selectedDeck.id, uploadedFile.name, 5);
          setGeneratedCards(mockGenerated);
          setViewMode('review-cards');
          toast.success(`Generated ${mockGenerated.length} flashcards!`);
          return 100;
        }
        return prev + 10;
      });
    }, 200);
  };

  // Save generated cards
  const handleSaveGeneratedCards = () => {
    const cardsToSave = generatedCards.filter((card) => selectedCards.has(card.id));
    setCards((prev) => [...prev, ...cardsToSave]);
    setDecks((prev) =>
      prev.map((deck) =>
        deck.id === selectedDeck?.id
          ? {
              ...deck,
              cardCount: deck.cardCount + cardsToSave.length,
              autoGenerated: deck.autoGenerated + cardsToSave.length,
            }
          : deck
      )
    );
    toast.success(`Added ${cardsToSave.length} cards to "${selectedDeck?.name}"`);
    setViewMode('decks');
    setUploadedFile(null);
    setGeneratedCards([]);
    setSelectedCards(new Set());
  };

  // Toggle card selection
  const toggleCardSelection = (cardId: string) => {
    setSelectedCards((prev) => {
      const newSet = new Set(prev);
      if (newSet.has(cardId)) {
        newSet.delete(cardId);
      } else {
        newSet.add(cardId);
      }
      return newSet;
    });
  };

  // Select all cards
  const selectAllCards = () => {
    setSelectedCards(new Set(generatedCards.map((c) => c.id)));
  };

  // Deselect all cards
  const deselectAllCards = () => {
    setSelectedCards(new Set());
  };

  // Convert card type
  const convertCardType = (cardId: string) => {
    setGeneratedCards((prev) =>
      prev.map((card) => {
        if (card.id === cardId) {
          if (card.type === 'basic') {
            return {
              ...card,
              type: 'cloze' as const,
              text: `${card.front} {{c1::${card.back}}}`,
              front: undefined,
              back: undefined,
            };
          } else {
            const text = card.text || '';
            const front = text.replace(/{{c\d+::/g, '').replace(/}}/g, '');
            return {
              ...card,
              type: 'basic' as const,
              front: 'Question',
              back: front,
              text: undefined,
            };
          }
        }
        return card;
      })
    );
    toast.success('Card type converted');
  };

  // Delete card
  const deleteCard = (cardId: string) => {
    setGeneratedCards((prev) => prev.filter((c) => c.id !== cardId));
    toast.success('Card deleted');
  };

  // Export to Anki
  const handleExport = () => {
    if (!selectedDeck) return;

    const deckCards = cards.filter((c) => c.deckId === selectedDeck.id);
    const filteredCards = deckCards.filter((card) => {
      if (exportSettings.cardType === 'all') return true;
      return card.type === exportSettings.cardType;
    });

    toast.success(`Exporting ${filteredCards.length} cards to ${selectedDeck.name}.apkg`);

    setTimeout(() => {
      toast.success('Export complete! File downloaded.');
      setViewMode('decks');
    }, 1000);
  };

  // Import from Anki
  const handleImportAnki = () => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.apkg,.colpkg';
    input.onchange = (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        if (!file.name.endsWith('.apkg') && !file.name.endsWith('.colpkg')) {
          toast.error('Please upload an Anki package (.apkg or .colpkg)');
          return;
        }

        toast.success(`Importing ${file.name}...`);

        setTimeout(() => {
          const mockImportedCards: Flashcard[] = [
            {
              id: `imp-${Date.now()}-1`,
              type: 'basic',
              front: 'What is the half-life of aspirin?',
              back: 'Approximately 2-3 hours for low doses, up to 15-30 hours for higher doses.',
              tags: ['Pharmacology', 'Imported'],
              deckId: selectedDeck?.id || 'deck1',
              source: 'imported',
              createdAt: new Date(),
              reviewCount: 0,
            },
            {
              id: `imp-${Date.now()}-2`,
              type: 'cloze',
              text: 'Aspirin irreversibly inhibits {{c1::COX-1}} and {{c2::COX-2}} enzymes.',
              tags: ['Pharmacology', 'Imported'],
              deckId: selectedDeck?.id || 'deck1',
              source: 'imported',
              createdAt: new Date(),
              reviewCount: 0,
            },
          ];

          setCards((prev) => [...prev, ...mockImportedCards]);
          toast.success(`Imported ${mockImportedCards.length} cards successfully!`);
        }, 1500);
      }
    };
    input.click();
  };

  // Create new deck
  const handleCreateDeck = (deck: Deck) => {
    setDecks((prev) => [deck, ...prev]);
  };

  // NEW: Folder management handlers
  const handleToggleFolderExpand = (folderId: string) => {
    setFolders((prev) =>
      prev.map((f) => (f.id === folderId ? { ...f, isExpanded: !f.isExpanded } : f))
    );
  };

  const handleCreateFolder = (name: string, parentId: string | null) => {
    const newFolder: Folder = {
      id: `folder-${Date.now()}`,
      name,
      parentId,
      color: '#3B82F6',
      deckCount: 0,
      cardCount: 0,
      isExpanded: true,
      createdAt: new Date(),
    };
    setFolders((prev) => [...prev, newFolder]);
    toast.success(`Folder "${name}" created`);
  };

  const handleRenameFolder = (folderId: string, newName: string) => {
    setFolders((prev) =>
      prev.map((f) => (f.id === folderId ? { ...f, name: newName } : f))
    );
    toast.success('Folder renamed');
  };

  const handleDeleteFolder = (folderId: string) => {
    const folder = folders.find((f) => f.id === folderId);
    if (!folder) return;

    // Get all descendant IDs
    const descendantIds = getDescendantIds(folderId, folders);

    // Check if any decks are in these folders
    const affectedDecks = decks.filter((d) => d.folderId && descendantIds.includes(d.folderId));

    if (affectedDecks.length > 0) {
      toast.error(`Cannot delete folder with ${affectedDecks.length} deck(s). Move them first.`);
      return;
    }

    // Delete folder and descendants
    setFolders((prev) => prev.filter((f) => !descendantIds.includes(f.id)));
    toast.success(`Folder "${folder.name}" deleted`);
  };

  const handleMoveFolder = (folderId: string, newParentId: string | null) => {
    setFolders((prev) =>
      prev.map((f) => (f.id === folderId ? { ...f, parentId: newParentId } : f))
    );
    toast.success('Folder moved');
  };

  return (
    <div className="flex-1 flex bg-bg-primary h-full overflow-hidden">
      {viewMode === 'decks' && (
        <DeckListView
          decks={decks}
          folders={folders}
          selectedFolderId={selectedFolderId}
          searchQuery={searchQuery}
          onSearchChange={setSearchQuery}
          onSelectFolder={setSelectedFolderId}
          onToggleFolderExpand={handleToggleFolderExpand}
          onCreateFolder={handleCreateFolder}
          onRenameFolder={handleRenameFolder}
          onDeleteFolder={handleDeleteFolder}
          onMoveFolder={handleMoveFolder}
          onDeckSelect={(deck) => {
            setSelectedDeck(deck);
            setViewMode('upload');
          }}
          onExportDeck={(deck) => {
            setSelectedDeck(deck);
            setViewMode('export');
          }}
          onImportAnki={handleImportAnki}
          onCreateDeck={() => setIsCreatingDeck(true)}
        />
      )}

      {viewMode === 'upload' && selectedDeck && (
        <UploadView
          selectedDeck={selectedDeck}
          uploadedFile={uploadedFile}
          isDragging={isDragging}
          onBack={() => {
            setViewMode('decks');
            setSelectedDeck(null);
            setUploadedFile(null);
          }}
          onFileSelect={handleFileSelect}
          onFileRemove={() => setUploadedFile(null)}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          onGenerate={handleGenerateFlashcards}
        />
      )}

      {viewMode === 'generating' && <GeneratingView progress={generationProgress} />}

      {viewMode === 'review-cards' && (
        <ReviewCardsView
          cards={generatedCards}
          selectedCards={selectedCards}
          onToggleCard={toggleCardSelection}
          onSelectAll={selectAllCards}
          onDeselectAll={deselectAllCards}
          onCancel={() => {
            setViewMode('upload');
            setGeneratedCards([]);
            setSelectedCards(new Set());
          }}
          onSave={handleSaveGeneratedCards}
          onConvertCard={convertCardType}
          onDeleteCard={deleteCard}
        />
      )}

      {viewMode === 'export' && selectedDeck && (
        <ExportView
          deck={selectedDeck}
          exportSettings={exportSettings}
          onBack={() => setViewMode('decks')}
          onSettingsChange={setExportSettings}
          onExport={handleExport}
        />
      )}

      <CreateDeckDialog
        open={isCreatingDeck}
        onOpenChange={setIsCreatingDeck}
        onCreateDeck={handleCreateDeck}
      />
    </div>
  );
}